buildParameterVars <- function(paramcode){
ncvar_def(paste("v", paramcode, "_value", sep = ""),
units = "", dim = list(layer_dim, ts_dim), prec = "double")
}
parameterVars <- lapply(params, buildParameterVars)
# v#####_valiated       boolean :: layer, time
buildValidatedVars <- function(paramcode){
ncvar_def(paste("v", paramcode, "_validated", sep = ""),
units = "", dim = list(layer_dim, ts_dim), prec = 'double')
}
validatedVars <- lapply(params, buildValidatedVars)
dChar <- max(unlist(lapply(descript, nchar)))
dDim <- ncdim_def("descriptChar", units = "", vals = 1:dChar, create_dimvar = FALSE)
buildDescriptorVars <- function(paramcode){
ncvar_def(paste("v", paramcode, "_description", sep = ""),
units = "", dim = list(dDim, layer_dim), prec = 'char')
}
descriptorVars <- lapply(params, buildDescriptorVars)
# site_no             char    :: layer, nchar
# station_nm          char    :: layer, nchar
# site_tp_cd          char    :: layer, nchar
# dec_coord_datum     char    :: layer, nchar
# alt_datum_cd        char    :: layer, nchar
# huc_cd              char    :: layer, nchar
# parm_cd             char    :: layer, nchar
# tz_cd               char    :: layer, nchar
# agency_cd           char    :: layer, nchar
# district_cd         char    :: layer, nchar
# county_cd           char    :: layer, nchar
# country_cd          char    :: layer, nchar
# dec_lat_va          double  :: layer
# dec_long_va         double  :: layer
# alt_va              double  :: layer
#meta.pad["familyid"] <- NULL
varTypes <- lapply(meta.pad[1,], typeof)
stringVars <- names(meta.pad)[which(varTypes == "character")]
# only string vars have extra dim
buildMetadataDims <- function(name){
maxChar <- max(unlist(lapply(meta.pad[name], nchar)))
ncdim_def(paste(name, "Char", sep = ""), units = "", vals = 1:maxChar, create_dimvar = FALSE )
}
metadataDims <- lapply(stringVars, buildMetadataDims)
buildMetadataVars <- function(name){
if(varTypes[name] == 'character'){
ncvar_def(name, units = "", dim = list(metadataDims[[which(stringVars == name)]], layer_dim), prec = 'char')
} else {
if(varTypes[name] == 'integer'){
ncvar_def(name, units = "", dim = list(layer_dim), prec = 'integer')
} else {
if(varTypes[name] == 'double'){
ncvar_def(name, units = "", dim = list(layer_dim), prec = 'double')
} else {
print("ERROR WHILE BUILDING METADATAVARS")
print(paste("(", varTypes[name], ",", name))
}
}
}
}
metadataVars <- lapply(names(meta.pad), buildMetadataVars)
# use verbose = TRUE to get more info on nc creation
out <- nc_create(paste("out/", startDate, ".nc", sep = ""), vars = c(list(timeVar), parameterVars, validatedVars, descriptorVars, metadataVars))
ncvar_put(out, "time", times)
data.pad.value <- data.pad[,-5]
data.pad.valid <- data.pad[,-4]
putData <- function(param_cd){
value = t(dcast(data.pad.value, ts ~ familyid, subset = .(paramcd == param_cd)))[-1,]
valid = t(dcast(data.pad.valid, ts ~ familyid, value.var = "validated", subset = .(paramcd == param_cd)))[-1,]
descr <- subset(descript, parm_cd = param_cd)
ncvar_put(out, paste("v", param_cd, "_value", sep = ""), value)
ncvar_put(out, paste("v", param_cd, "_validated", sep = ""), valid)
ncvar_put(out, paste("v", param_cd, "_description", sep = ""), unlist(descr))
}
cc <- lapply(params, putData)
# free memory
remove(data.pad.value, data.pad.valid, data.pad)
putStationMetadata <- function(name){
ncvar_put(out, name, vals = unlist(meta.pad[name]))
}
cc <- lapply(names(meta.pad), putStationMetadata)
nc_close(out)
require(RPostgreSQL)
require(doParallel)
require(plyr)
require(reshape2)
require(lubridate)
require(ncdf4)
require(data.table)
drv2 <- dbDriver("PostgreSQL")
con2 <- dbConnect(drv2, dbname = "postgres", user = "postgres", host = "localhost", password = "usgs")
t <- dbGetQuery(con, "select min(ts)::date, max(ts)::date from data;")
dates <- seq(t$min, t$max, 1)
pairs <- data.frame(startDate = format(dates[-length(dates)]), endDate = format(dates[-1]), stringsAsFactors = FALSE)
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname = "postgres", user="postgres", host="localhost", password="usgs")
t <- dbGetQuery(con, "select min(ts)::date, max(ts)::date from data;")
dates <- seq(t$min, t$max, 1)
pairs <- data.frame(startDate = format(dates[-length(dates)]), endDate = format(dates[-1]), stringsAsFactors = FALSE)
paris
pairs
startDate = "2014-12-10"
endDate = "2014-12-11"
debugMode = FALSE;
tc <- function(X){
time1 <- as.POSIXct(X)
# time1 <- fast_strptime(X, format="%Y-%m-%dT%H:%M:%OS%z")
time0 <- as.POSIXct("1970-01-01 00:00:00", tz = "UTC")
sec <- as.numeric(difftime(time1, time0, units="secs"))
gettextf("%.0f", sec)
}
data <- dbGetQuery(con2, paste("
SELECT
data.ts,
data.familyid,
data.paramcd,
data.value,
data.validated
FROM
public.data
WHERE
data.ts >= '", startDate,"' AND
data.ts < '", endDate, "';", sep = ""))
metadata <- dbGetQuery(con2, paste("SELECT * FROM  meta_station"))
descript <- dbGetQuery(con2, paste("SELECT * FROM  meta_param"))
# nLayers
layers <- sort(unique(data$familyid))
nLayers <- length(layers)
# nTimes
data$ts <- tc(data$ts)
times <- sort(unique(data$ts))
nTimes <- length(times)
# nParams
params <- unique(data$paramcd)
nParams <- length(params)
data.pad <- CJ(ts = times, familyid = layers, paramcd = params, stringsAsFactors = FALSE)
data.pad
join
?join
typeof(data.pad)
typeof(data.pad)
names(data.pad)
?join
?join
?merge
meta.pad1 <- join(expand.grid(familyid = layers, stringsAsFactors = FALSE),
metadata,
by = c("familyid"))
head(meta.pad1)
meta.pad2 <- merge(CJ(familyid = layers),
metadata,
by = c("familyid"), all.x = TRUE, all.y = FALSE)
meta.pad2
head(meta.pad2)
head(meta.pad2)
head(meta.pad1)
nrow(meta.pad1)
nrow(meta.pad2)
typeof(meta.pad1)
typeof(meta.pad2)
object.size()
object.size(meta.pad1)
object.size(meta.pad2)
data.pad1 <- join(data.pad, data, by = c("ts", "familyid", "paramcd"))
data.pad2 <- merge(data.pad, data, by = c("ts", "familyid", "paramcd"), all.x = TRUE, all.y = FALSE)
head(data.pad1)
head(data.pad2)
data.pad <- CJ(ts = times, familyid = layers, paramcd = params)
data.pad1 <- join(data.pad, data, by = c("ts", "familyid", "paramcd"))
data.pad2 <- merge(data.pad, data, by = c("ts", "familyid", "paramcd"), all.x = TRUE, all.y = FALSE)
data.pad1
data.pad2
length(data.pad1)
length(data.pad2)
dim(data.pad1)
dim(data.pad2)
metadata <- data.table(dbGetQuery(con2, paste("SELECT * FROM  meta_station")))
descript <- data.table(dbGetQuery(con2, paste("SELECT * FROM  meta_param")))
data.pad
data.pad[,-5]
?subset
select(data.pad)
?select
select
?subset
head(data.pad)
data.pad <- merge(data.pad, data, by = c("ts", "familyid", "paramcd"), all.x = TRUE, all.y = FALSE)
data.pad
select(data.pad, subset=c("ts", "familyid", "paramcd"))
subset(data.pad, select=c("ts", "familyid", "paramcd"))
subset(data.pad, select=c("ts", "familyid", "paramcd", "valid"))
subset(data.pad, select=c("ts", "familyid", "paramcd", "validated"))
install.packages("yaml")
ls
??yaml
yaml.load("foo: bar\n123: 456", as.named.list = FALSE
)
require(yaml)
yaml.load("foo: bar\n123: 456", as.named.list = FALSE
)
tt <- yaml.load("foo: bar\n123: 456", as.named.list = FALSE)
tt
tt["foo"]
tt$foo
tt$foo(1)
tt$bar
tt$foo
doc <- yaml.load("inc: !expr function(x) x + 1")
doc
setwd("~/Desktop/nwis-simple")
?yaml.load
?yaml.load_file("*.yaml")
yaml.load_file("config.yaml")
yaml.load_file("config.yaml")
yaml.load_file("config.yaml")
date
date()
format(date())
?date
format(Sys.time(), %a %b %d)
format(Sys.time(), "%a %b %d")
format(Sys.time(), "%Y %M %D")
format(Sys.time(), "%Y-%M %D")
format(Sys.time(), "%Y-%m-%d")
format(Sys.time(), "%Y-%m-%d")
gg <- format(Sys.time(), "%Y-%m-%d")
typeof(gg)
?foreach
library(foreach)
??foreach
?foreach
yaml.load_file("config.yaml")
source("getDay.R")
gg <- format(Sys.time(), "%Y-%m-%d")
gg
setupCluster <- function(){
cl <- makePSOCKcluster(detectCores(), outfile = "")
registerDoParallel(cl)
cc <- clusterEvalQ(cl, {
require(RPostgreSQL)
require(RCurl)
require(XML)
drv2 <- dbDriver("PostgreSQL")
con2 <- dbConnect(drv2, dbname = "postgres", user="postgres", host="localhost", password="usgs")
source("download.R")
})
}
closeCluster <- function(){
cc <- clusterEvalQ(cl, {
dbDisconnect(con2)
dbUnloadDriver(drv2)
})
cc <- stopCluster(cl)
}
getDay <- function(date){
cat("===========================================\n")
cat(paste("Building Table ::", date)
cat(paste("Downloading data from",
nrow(sites), "sites...\n"))
pb <- txtProgressBar(min = 1, max = nrow(sites)+1, style = 3)
cc <- foreach(i = 1) %dopar% {
getDay(site = sites[i,1],
params = params,
date = date,
offset = offset)
}
cc <- foreach(i = 2:nrow(sites)) %dopar% {
setTxtProgressBar(pb, i)
result = tryCatch({
bootstrap(site = sites[i,1],
params = params,
date = date,
offset = offset,
delay = runif(1, 0.1, 0.6))
}, warning = function(w) {
}, error = function(e) {
error <- paste("\nSite:",
sites[i,1],
"at index",
i,
"failed:",
e)
cat(error)
}, finally = {
})
}
setTxtProgressBar(pb, nrow(sites)+1)
}
daysAgo<- function(x){
return(Sys.time() - x, "%Y-%m-%d")
}
full <- lapply(1:35, daysAgo)
full <- lapply(list(1:35), daysAgo)
gg <- format(Sys.time() - 1, "%Y-%m-%d")
gg
gg <- format(Sys.time() - 25, "%Y-%m-%d")
gg <- format(Sys.time() - 25, "%Y-%m-%d")
gg
?Sys.time()
Sys.date()
Sys.Date()
Sys.Date()-1
daysAgo<- function(x){
return(Sys.Dime() - x, "%Y-%m-%d")
}
full <- lapply(list(1:35), daysAgo)
daysAgo<- function(x){
return(format(Sys.Dime() - x, "%Y-%m-%d"))
}
full <- lapply(1:35, daysAgo)
daysAgo<- function(x){
return(format(Sys.Date() - x, "%Y-%m-%d"))
}
full <- lapply(1:35, daysAgo)
full
config <- yaml.load_file("config.yaml")
config
setupCluster <- function(){
cl <- makePSOCKcluster(detectCores(), outfile = "")
registerDoParallel(cl)
cc <- clusterEvalQ(cl, {
require(RPostgreSQL)
require(RCurl)
require(XML)
drv2 <- dbDriver("PostgreSQL")
con2 <- dbConnect(drv2, dbname = "postgres", user="postgres", host="localhost", password="usgs")
source("download.R")
})
}
closeCluster <- function(){
cc <- clusterEvalQ(cl, {
dbDisconnect(con2)
dbUnloadDriver(drv2)
})
cc <- stopCluster(cl)
}
getDay <- function(sites, date, params, offset){
cat("===========================================\n")
cat(paste("Building Table ::", date)
cat(paste("Downloading data from",
nrow(sites), "sites...\n"))
pb <- txtProgressBar(min = 1, max = nrow(sites)+1, style = 3)
cc <- foreach(i = 1) %dopar% {
getDay(site = sites[i,1],
params = params,
date = date,
offset = offset)
}
cc <- foreach(i = 2:nrow(sites)) %dopar% {
setTxtProgressBar(pb, i)
result = tryCatch({
bootstrap(site = sites[i,1],
params = params,
date = date,
offset = offset,
delay = runif(1, 0.1, 0.6))
}, warning = function(w) {
}, error = function(e) {
error <- paste("\nSite:",
sites[i,1],
"at index",
i,
"failed:",
e)
cat(error)
}, finally = {
})
}
setTxtProgressBar(pb, nrow(sites)+1)
}
daysAgo<- function(x){
return(format(Sys.Date() - x, "%Y-%m-%d"))
}
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname = "postgres", user="postgres", host="localhost", password="usgs")
sites <- dbGetQuery(con, "SELECT site_no from activesites;")
full <- lapply(1:35, daysAgo)
config <- yaml.load_file("config.yaml")
getDay(sites = sites,
date = daysAgo(1),
params = config$collections$params,
offset = config$midnight.offset.standard)
setupCluster <- function(){
cl <- makePSOCKcluster(detectCores(), outfile = "")
registerDoParallel(cl)
cc <- clusterEvalQ(cl, {
require(RPostgreSQL)
require(RCurl)
require(XML)
drv2 <- dbDriver("PostgreSQL")
con2 <- dbConnect(drv2, dbname = "postgres", user="postgres", host="localhost", password="usgs")
source("download.R")
})
}
closeCluster <- function(){
cc <- clusterEvalQ(cl, {
dbDisconnect(con2)
dbUnloadDriver(drv2)
})
cc <- stopCluster(cl)
}
getDay <- function(sites, date, params, offset){
cat("===========================================\n")
cat(paste("Building Table ::", date))
cat(paste("Downloading data from",
nrow(sites), "sites...\n"))
pb <- txtProgressBar(min = 1, max = nrow(sites)+1, style = 3)
cc <- foreach(i = 1) %dopar% {
getDay(site = sites[i,1],
params = params,
date = date,
offset = offset)
}
cc <- foreach(i = 2:nrow(sites)) %dopar% {
setTxtProgressBar(pb, i)
result = tryCatch({
bootstrap(site = sites[i,1],
params = params,
date = date,
offset = offset,
delay = runif(1, 0.1, 0.6))
}, warning = function(w) {
}, error = function(e) {
error <- paste("\nSite:",
sites[i,1],
"at index",
i,
"failed:",
e)
cat(error)
}, finally = {
})
}
setTxtProgressBar(pb, nrow(sites)+1)
}
daysAgo<- function(x){
return(format(Sys.Date() - x, "%Y-%m-%d"))
}
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname = "postgres", user="postgres", host="localhost", password="usgs")
sites <- dbGetQuery(con, "SELECT site_no from activesites;")
full <- lapply(1:35, daysAgo)
config <- yaml.load_file("config.yaml")
getDay(sites = sites,
date = daysAgo(1),
params = config$collections$params,
offset = config$midnight.offset.standard)
getDay <- function(sites, date, params, offset){
cat("===========================================\n")
cat(paste("Building Table ::", date))
cat(paste("Downloading data from",
nrow(sites), "sites...\n"))
pb <- txtProgressBar(min = 1, max = nrow(sites)+1, style = 3)
cc <- foreach(i = 1) %dopar% {
download(site = sites[i,1],
params = params,
date = date,
offset = offset)
}
cc <- foreach(i = 2:nrow(sites)) %dopar% {
setTxtProgressBar(pb, i)
result = tryCatch({
download(site = sites[i,1],
params = params,
date = date,
offset = offset,
delay = runif(1, 0.1, 0.6))
}, warning = function(w) {
}, error = function(e) {
error <- paste("\nSite:",
sites[i,1],
"at index",
i,
"failed:",
e)
cat(error)
}, finally = {
})
}
setTxtProgressBar(pb, nrow(sites)+1)
}
daysAgo<- function(x){
return(format(Sys.Date() - x, "%Y-%m-%d"))
}
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname = "postgres", user="postgres", host="localhost", password="usgs")
sites <- dbGetQuery(con, "SELECT site_no from activesites;")
full <- lapply(1:35, daysAgo)
config <- yaml.load_file("config.yaml")
getDay(sites = sites,
date = daysAgo(1),
params = config$collections$params,
offset = config$midnight.offset.standard)
source("download.R")
setupCluster()
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/main.R')
date
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/download.R')
source('~/Desktop/nwis-simple/main.R')
print(head(res))
setupCluster <- function(){
source('~/Desktop/nwis-simple/main.R')
)))
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/download.R')
source('~/Desktop/nwis-simple/bootstrapFn.R')
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/bootstrapFn.R')
source('~/Desktop/nwis-simple/main.R')
source('~/Desktop/nwis-simple/main.R')
